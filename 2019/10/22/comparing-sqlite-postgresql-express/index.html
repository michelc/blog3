<!doctype html>
<html lang="en-US">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Comparing SQlite or PostgreSQL with Express - blog.pagesd.info</title>
    <link rel="shortcut icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" href="/atom.xml" title="blog.pagesd.info" type="application/atom+xml">
    <meta name="author" content="Michel" />
<link rel="canonical" href="https://blog3.pagesd.info/2019/10/22/comparing-sqlite-postgresql-express/" />
<meta property="og:title" content="Comparing SQlite or PostgreSQL with Express" />
<meta name="description" content="After writing two Node JS + Express tutorials to access SQlite then PostgreSQL databases, I found that there were not such big gaps between the two systems." />
<meta property="og:description" content="After writing two Node JS + Express tutorials to access SQlite then PostgreSQL databases, I found that there were not such big gaps between the two systems." />
<meta property="og:locale" content="en-US" />
<meta property="og:url" content="https://blog3.pagesd.info/2019/10/22/comparing-sqlite-postgresql-express/" />
<meta property="og:site_name" content="blog.pagesd.info" />
<meta property="og:type" content="article" />
<meta property="og:image" content="https://blog3.pagesd.info/public/2019/microscope.jpg" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="article:published_time" content="2019-10-22T10:20:34.000Z" />
<script type="application/ld+json">{"headline":"blog.pagesd.info","dateModified":"2019-10-22T10:20:34.000Z","datePublished":"2019-10-22T10:20:34.000Z","description":"After writing two Node JS + Express tutorials to access SQlite then PostgreSQL databases, I found that there were not such big gaps between the two systems.","inLanguage":"en-US","url":"https://blog3.pagesd.info/2019/10/22/comparing-sqlite-postgresql-express/","@type":"BlogPosting","image":"https://blog3.pagesd.info/public/2019/microscope.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog3.pagesd.info/2019/10/22/comparing-sqlite-postgresql-express/"},"author":{"@type":"Person","name":"Michel"},"@context":"https://schema.org"}</script>
  </head>

  <body><div class="container">

    <header><nav>
      <a class="title" href="/">blog.pagesd.info</a>
      // <a href="/archives/">archives</a>
      // <a href="/traductions/">traductions</a>
    </nav></header>



<article>

<figure class="cover-image"><img src="/public/2019/microscope.jpg" alt="Observing samples under the microscope - Trust "Tru" Katsande" /><figcaption><a href="https://unsplash.com/photos/6q5QG8iIgRo">Observing samples under the microscope - Trust "Tru" Katsande</a></figcaption></figure>

  <header>
    <h1>
      <a href="/2019/10/22/comparing-sqlite-postgresql-express/">Comparing SQlite or PostgreSQL with Express</a>
    </h1>
    <p>
      <span>2019-10-22</span>
      <span>#javascript</span><span>#node</span><span>#sql</span>
    </p>
  </header>

  <div>

<p>After writing two tutorials on Express to access <a href="/2019/10/08/crud-with-express-sqlite-10-steps/">SQlite</a> and <a href="/2019/10/15/crud-with-express-postgresql-10-steps/">PostgreSQL</a> databases, I realized that there were not such big gaps between the two systems.</p>
<p>For the moment, I have seen 5 differences, more or less important:</p>
<ul>
<li>Marker for SQL parameters: &quot;$1&quot; or &quot;?&quot;</li>
<li>The way to define the parameters: always an array or not</li>
<li>Available methods: .query() or .run() + .all() +.get()</li>
<li>Parameters passed to the callback function</li>
<li>Names of the columns in lowercase</li>
</ul>
<h2>Markers for SQL parameters</h2>
<p>Generally, examples for SQlite use &quot;?, ?, ? ...&quot; to identify parameters in parameterized queries. So I followed this method. When you go to PostgreSQL, you see more like &quot;$1, $2, $3 ...&quot;.</p>
<pre><code class="language-javascript">db.run(&quot;UPDATE Books SET Title = ? WHERE Book_ID = ?&quot;, [title, id], callback);
query.pool(&quot;UPDATE Books SET Title = $1 WHERE Book_ID = $2&quot;, [title, id], callback);
</code></pre>
<p>But this is absolutely not a problem, because the SQlite database supports very well parameters in the form &quot;$1, $2, $3 ...&quot;.</p>
<pre><code class="language-javascript">db.run(&quot;UPDATE Books SET Title = $1 WHERE Book_ID = $2&quot;, [title, id], callback);
</code></pre>
<p>One!</p>
<h2>SQL parameters in tabular form</h2>
<p>When there is only one SQL parameter, the SQlite3 module accepts that this unique data is transmitted as a value, and not within an array:</p>
<pre><code class="language-javascript">db.get(&quot;SELECT * FROM Books WHERE Books_ID = $1&quot;, id, callback);
</code></pre>
<p>Whereas for the node-postgres module, it's imperative that it be within an array:</p>
<pre><code class="language-javascript">pool.query(&quot;SELECT * FROM Books WHERE Books_ID = $1&quot;, [id], callback);
</code></pre>
<p>Similarly, when it's not a parameterized query, the SQlite3 module allows the parameter to be completely zapped, whereas the node-postgres module requires an empty array:</p>
<pre><code class="language-javascript">db.all(&quot;SELECT * FROM Books&quot;, callback);
pool.query(&quot;SELECT * FROM Books&quot;, [], callback);
</code></pre>
<p>But this time, the SQlite3 module is very flexible and we can do exactly as with node-postgres :</p>
<pre><code class="language-javascript">db.get(&quot;SELECT * FROM Books WHERE Books_ID = $1&quot;, [id], callback);
db.all(&quot;SELECT * FROM Books&quot;, [], callback);
</code></pre>
<p>It's even better, because that way you're sure you haven't forgotten a parameter by mistake.</p>
<p>Two.</p>
<h2>.query() vs .run(), .all() and .get()</h2>
<p>The SQlite3 module defines 3 methods:</p>
<ul>
<li><code>.run()</code> to run update queries</li>
<li><code>.all()</code> to perform SELECTs that return multiple rows</li>
<li><code>.get()</code> for SELECTs by identifier that return a single line</li>
</ul>
<p>While on the node-postgres side, everything is done with a single <code>.query()</code> method.</p>
<p>After some tests, we can always use the <code>.all()</code> method from the SQlite3 module, because it handles perfectly:</p>
<ul>
<li>the &quot;SELECT&quot; for an identifier: it seemed obvious</li>
<li>all update queries: cool!</li>
</ul>
<p>We can therefore write without any problem:</p>
<pre><code class="language-javascript">db.all(&quot;CREATE TABLE Books ...&quot;, [], callback);
db.all(&quot;UPDATE Books SET Title = $1 WHERE Book_ID = $2&quot;, [title, id], callback);
db.all(&quot;SELECT * FROM Books WHERE Books_ID = $1&quot;, [id], callback);
db.all(&quot;SELECT * FROM Books&quot;, [], callback);
</code></pre>
<p>Just like we do with node-postgres:</p>
<pre><code class="language-javascript">pool.query(&quot;CREATE TABLE Books ...&quot;, [], callback);
pool.query(&quot;UPDATE Books SET Title = $1 WHERE Book_ID = $2&quot;, [title, id], callback);
pool.query(&quot;SELECT * FROM Books WHERE Books_ID = $1&quot;, [id], callback);
pool.query(&quot;SELECT * FROM Books&quot;, [], callback);
</code></pre>
<p>Three...</p>
<h2>Callback function parameters</h2>
<p>The <code>.query()</code> method of the node-postgres module always returns 2 objects to the callback function that it chains:</p>
<ul>
<li>an <code>Error</code> object (according to the &quot;error-first&quot; pattern popularized by Node)</li>
<li>a <code>Result</code> object that contains the result returned by the executed query and information about the execution of this query.</li>
</ul>
<p>On the SQlite3 module side, the <code>.all()</code> method also provides 2 objects to its callback function :</p>
<ul>
<li>an <code>Error</code> object (we're good)</li>
<li>an array of &quot;rows&quot; that contains the rows returned by the query.</li>
</ul>
<p>Then, as we use <code>.all()</code> to do everything, it will actually give:</p>
<ul>
<li>an array with the list of rows for a &quot;SELECT&quot; query returning multiple lines</li>
<li>an array with the unique row found for a &quot;SELECT&quot; query by identifier</li>
<li>an empty array for an update request</li>
</ul>
<p>This is where you have to trick and kill two birds with one stone by adding a <code>.query()</code> method to the <code>Database</code> object of the SQlite3 module in order to return an object that looks like the <code>Result</code> of the node-postgres module :</p>
<pre><code class="language-javascript">db.query = function (sql, params, callback) {
  if (!Array.isArray(params)) throw new Error(&quot;params is not an array!&quot;);
  this.all(sql, params, function (err, rows) {
    callback(err, { rows: rows });
  });
};
</code></pre>
<p><em>Note: I throw an error if &quot;params&quot; is not an array because the goal during development on SQlite is to be the closest to what will work in production with PostgreSQL. And so, if I forget to use an array, it's better to crash during development rather than in production.</em></p>
<p>Thanks to this new method, we can finally write the same code for SQlite (via the SQlite3 module) as for PostgreSQL (via the node-postgres module), excepted for the main object name:</p>
<pre><code class="language-javascript">xxx.query(&quot;CREATE TABLE Books...&quot;, [], (err, result) =&gt; {});
xxx.query(&quot;UPDATE Books SET Title = $1 WHERE Book_ID = $2&quot;, [title, id], (err, result) =&gt; {});
xxx.query(&quot;SELECT * FROM Books WHERE Books_ID = $1&quot;, [id], (err, result) =&gt; {});
xxx.query(&quot;SELECT * FROM Books&quot;, [], (err, result) =&gt; {});
</code></pre>
<p>It's four!</p>
<h2>The lowercase problem</h2>
<p>I usually write SQL keywords in capital letters and the names of tables, columns, views, sequences ... in PascalCase.</p>
<p>It works very well in C# with ADO.NET / <a href="https://stackexchange.github.io/Dapper/">Dapper</a>. In Ruby, I didn't have any problems (probably because I've always used <a href="https://datamapper.org/">DataMapper</a> or <a href="https://sequel.jeremyevans.net/">Sequel</a>). But in JavaScript it becomes annoying as it's a very sensitive language.</p>
<p>So, in both tutorials, I created my test table as follows:</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS Books (
  Book_ID XXXXXXXXXXXXXXXXXX,
  Title VARCHAR(100) NOT NULL,
  Author VARCHAR(100) NOT NULL,
  Comments TEXT
);
</code></pre>
<p>The SQlite database followed my way of writing and created a &quot;Books&quot; table with the columns &quot;Book_ID&quot;, &quot;Title&quot;, &quot;Author&quot; and &quot;Comments&quot;.</p>
<p>The PostgreSQL database has all lowercase and created a &quot;books&quot; table with the columns &quot;book_id&quot;, &quot;title&quot;, &quot;author&quot; and &quot;comments&quot;.</p>
<p>In both cases, I can write SQL queries as I want:</p>
<pre><code class="language-sql">SELECT Title FROM Books WHERE Book_ID = 1
SELECT title FROM FROM books WHERE book_id = 1
SELECT TITLE FROM FROM books WHERE book_Id = 1
...
</code></pre>
<p>But in both cases, the property names of the resulting object exactly match the names of the columns in the database.</p>
<p>And therefore, for the following query:</p>
<pre><code class="language-javascript">xxx.query(&quot;SELECT * FROM Books WHERE book_ID = $1&quot;, [1], (err, result) =&gt; {
  console.log(result.rows[0]);
});
</code></pre>
<p>I get this object with SQlite3:</p>
<pre><code class="language-javascript">{
  Book_ID: 1,
  Title: &quot;Mrs. Bridge&quot;,
  Author: &quot;Evan S. Connell&quot;,
  Comments: &quot;First of the series&quot;
}
</code></pre>
<p>And this one with node-postgres:</p>
<pre><code class="language-javascript">{
  book_id: 1,
  title: &quot;Mrs. Bridge&quot;,
  author: &quot;Evan S. Connell&quot;,
  comments: &quot;First of the series&quot;
}
</code></pre>
<p>Ok. There's no need to complicate my life, and the simplest thing is that I always use lowercase letters to name objects in the database (at least in <a href="https://en.wikipedia.org/wiki/Data_definition_language">Data Definition Language queries</a>):</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS books (
  book_id XXXXXXXXXXXXXXXXXX,
  title VARCHAR(100) NOT NULL,
  author VARCHAR(100) NOT NULL,
  comments TEXT
);
</code></pre>
<p>And five =&gt; no more difference.</p>
<h2>Use a &quot;common&quot; object</h2>
<p>Currently, I do not use the same way to connect to databases:</p>
<pre><code class="language-javascript">// SQlite
const db = new sqlite3.Database(db_name, err =&gt; { ... });
// PostgreSQL
const pool = new Pool({ ... });
</code></pre>
<p>First of all, I will always name the variable &quot;db&quot; because &quot;pool&quot; is not great. And most importantly, I will use <code>process.env.NODE_ENV</code> to choose how to make the connection.</p>
<p>That will give something like:</p>
<pre><code class="language-javascript">// Connection to the database
let db = null;
if (process.env.NODE_ENV === &quot;production&quot;) {
  // PostgreSQL
  db = new Pool({
    ...
  });
} else {
  // SQlite
  const db_name = path.join(__dirname, &quot;data&quot;, &quot;apptest.db&quot;);
  db = new sqlite3.Database(db_name, err =&gt; {
    ...
  });
  // Hack to look like node-postgres
  db.query = function (sql, params, callback) {
    ...
  };
}
console.log(&quot;Successful connection to the database&quot;);
</code></pre>
<p><em>Note: I should search how to isolate this confusing things in 2 separate files. But later...</em></p>
<h2>Conclusion</h2>
<p>I solved all problems related to the fact that SQlite3 and node-postgres modules work a little differently. It only took a few modifications to successfully develop a simple enough solution to have exactly the same code for both databases:</p>
<ul>
<li>SQlite for development</li>
<li>PostgreSQL in production</li>
</ul>
<p>I don't need to manage more than these two databases. This is already what I am doing with Sinatra (SQlite + PostgreSQL) or ASP.NET MVC (SQL Server CE + SQL Server).</p>
<p>However, there are still some problems with SQL. It's a pretty standard language, but you have to be careful. For example, to create the unique identifier in the &quot;books&quot; table, I have to do it differently depending on the database:</p>
<ul>
<li>SQlite : <code>book_id INTEGER PRIMARY KEY AUTOINCREMENT</code></li>
<li>PostgreSQL : <code>book_id SERIAL PRIMARY KEY</code></li>
</ul>
<p>And then there are a few other things. But this shouldn't be too much of a problem for &quot;small&quot; beginner applications and tutorials. If I need to do more, it will mean it's time for me to look at ORMs (or make separate SQL scripts).</p>
<p>In the meantime, I can once again add a hack:</p>
<pre><code class="language-javascript">db.query = function (sql, params, callback) {
  if (!Array.isArray(params)) throw new Error(&quot;params is not an array!&quot;);
  sql = sql.replace(/SERIAL PRIMARY KEY/, &quot;INTEGER PRIMARY KEY AUTOINCREMENT&quot;);
  this.all(sql, params, function (err, rows) {
    callback(err, { rows: rows });
  });
};
</code></pre>
<p><em>Note: It must slow down a tad, but we're in development, it gives us time to think.</em></p>
<h2>The complete code for &quot;index.js&quot;</h2>
<p>As always, the entire &quot;index.js&quot; file to get an overview of the new system.</p>
<pre><code class="language-javascript">const express = require(&quot;express&quot;);
const path = require(&quot;path&quot;);
const { Pool } = require(&quot;pg&quot;);
const sqlite3 = require(&quot;sqlite3&quot;).verbose();

// Creating the Express server
const app = express();

// Server configuration
app.set(&quot;view engine&quot;, &quot;ejs&quot;);
app.set(&quot;views&quot;, path.join(__dirname, &quot;views&quot;));
app.use(express.static(path.join(__dirname, &quot;public&quot;)));
app.use(express.urlencoded({ extended: false }));

// Database connection
let db = null;
if (process.env.NODE_ENV === &quot;production&quot;) {
  // PostgreSQL in production
  const pool = new Pool({
    user: &quot;mystery&quot;,
    host: &quot;xxxxx.elephantsql.com&quot;,
    database: &quot;mystery&quot;,
    password: &quot;asecretthingthatnoonehastosee&quot;,
    port: 5432
  });
} else {
  // SQlite by default
  const db_name = path.join(__dirname, &quot;data&quot;, &quot;apptest.db&quot;);
  db = new sqlite3.Database(db_name, err =&gt; {
    if (err) {
      return console.error(err.message);
    }
  });
  // Hack to look like node-postgres
  db.query = function (sql, params, callback) {
    if (!Array.isArray(params)) throw new Error(&quot;params is not an array!&quot;);
    sql = sql.replace(/SERIAL PRIMARY KEY/, &quot;INTEGER PRIMARY KEY AUTOINCREMENT&quot;);
    this.all(sql, params, function (err, rows) {
      callback(err, { rows: rows });
    });
  };
}
console.log(&quot;Successful connection to the database&quot;);

// Creating the Books table (Book_ID, Title, Author, Comments)
const sql_create = `CREATE TABLE IF NOT EXISTS books (
  book_id SERIAL PRIMARY KEY,
  title VARCHAR(100) NOT NULL,
  author VARCHAR(100) NOT NULL,
  comments TEXT
);`;
db.query(sql_create, [], (err, result) =&gt; {
  if (err) {
    return console.error(err.message);
  }
  console.log(&quot;Successful creation of the 'Books' table&quot;);
  // Database seeding
  db.query(&quot;SELECT COUNT(*) AS count FROM Books&quot;, [], (err, result) =&gt; {
    const count = result.rows[0].count;
    if (count === 0) {
      const sql_insert = `INSERT INTO Books (Title, Author, Comments) VALUES
        ('Mrs. Bridge', 'Evan S. Connell', 'First of the series'),
        ('Mr. Bridge', 'Evan S. Connell', 'Second in the series'),
        ('L\'ingénue libertine', 'Colette', 'Minne + Les égarements de Minne');`;
      db.query(sql_insert, [], (err, result) =&gt; {
        if (err) {
          return console.error(err.message);
        }
        console.log(&quot;Successful creation of 3 books&quot;);
      });
    }
  });
});

// Starting the server
app.listen(3000, () =&gt; {
  console.log(&quot;Server started (http://localhost:3000/) !&quot;);
});

// GET /
app.get(&quot;/&quot;, (req, res) =&gt; {
  // res.send(&quot;Hello world...&quot;);
  res.render(&quot;index&quot;);
});

// GET /about
app.get(&quot;/about&quot;, (req, res) =&gt; {
  res.render(&quot;about&quot;);
});

// GET /data
app.get(&quot;/data&quot;, (req, res) =&gt; {
  const test = {
    titre: &quot;Test&quot;,
    items: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
  };
  res.render(&quot;data&quot;, { model: test });
});

// GET /books
app.get(&quot;/books&quot;, (req, res) =&gt; {
  const sql = &quot;SELECT * FROM Books ORDER BY Title&quot;;
  db.all(sql, [], (err, rows) =&gt; {
    if (err) {
      return console.error(err.message);
    }
    res.render(&quot;books&quot;, { model: rows });
  });
});

// GET /create
app.get(&quot;/create&quot;, (req, res) =&gt; {
  res.render(&quot;create&quot;, { model: {} });
});

// POST /create
app.post(&quot;/create&quot;, (req, res) =&gt; {
  const sql = &quot;INSERT INTO Books (Title, Author, Comments) VALUES ($1, $2, $3)&quot;;
  const book = [req.body.title, req.body.author, req.body.comments];
  db.run(sql, book, err =&gt; {
    if (err) {
      return console.error(err.message);
    }
    res.redirect(&quot;/books&quot;);
  });
});

// GET /edit/5
app.get(&quot;/edit/:id&quot;, (req, res) =&gt; {
  const id = req.params.id;
  const sql = &quot;SELECT * FROM Books WHERE Book_ID = $1&quot;;
  db.get(sql, id, (err, row) =&gt; {
    if (err) {
      return console.error(err.message);
    }
    res.render(&quot;edit&quot;, { model: row });
  });
});

// POST /edit/5
app.post(&quot;/edit/:id&quot;, (req, res) =&gt; {
  const id = req.params.id;
  const book = [req.body.title, req.body.author, req.body.comments, id];
  const sql = &quot;UPDATE Books SET Title = $1, Author = $2, Comments = $3 WHERE (Book_ID = $4)&quot;;
  db.run(sql, book, err =&gt; {
    if (err) {
      return console.error(err.message);
    }
    res.redirect(&quot;/books&quot;);
  });
});

// GET /delete/5
app.get(&quot;/delete/:id&quot;, (req, res) =&gt; {
  const id = req.params.id;
  const sql = &quot;SELECT * FROM Books WHERE Book_ID = $1&quot;;
  db.get(sql, id, (err, row) =&gt; {
    if (err) {
      return console.error(err.message);
    }
    res.render(&quot;delete&quot;, { model: row });
  });
});

// POST /delete/5
app.post(&quot;/delete/:id&quot;, (req, res) =&gt; {
  const id = req.params.id;
  const sql = &quot;DELETE FROM Books WHERE Book_ID = $1&quot;;
  db.run(sql, id, err =&gt; {
    if (err) {
      return console.error(err.message);
    }
    res.redirect(&quot;/books&quot;);
  });
});
</code></pre>
<div class="encart">
<p>Version en français : <a href="/2019/10/07/comparaison-sqlite-postgresql-express/" hreflang="fr-FR">Comparaison de l'utilisation de SQlite ou PostgreSQL avec Express</a>.</p>
</div>


  </div>

</article><nav class="paginate">
  <a rel="prev" href="/2019/10/21/utiliser-sqlite-node-async-await/" hreflang="fr-FR">Utiliser SQlite3 en mode async / await</a>
  <a rel="next" href="/2019/10/29/use-sqlite-node-async-await/" hreflang="en-US">Use SQlite3 in async / await mode</a>
</nav>



    <footer>
      <a href="/">blog.pagesd.info</a> ///
      <a href="https://www.solitaire-play.com/">www.solitaire-play.com</a>
    </footer>

  </div></body>

</html>

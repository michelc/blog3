<!doctype html>
<html lang="fr-FR">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>NerdDinner(fr) : Construire le modèle - blog.pagesd.info</title>
    <link rel="shortcut icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" href="/atom.xml" title="blog.pagesd.info" type="application/atom+xml">
    <meta name="author" content="Michel" />
<link rel="canonical" href="https://blog.pagesd.info/nerddinner/construire-modele/" />
<meta property="og:title" content="NerdDinner(fr) : Construire le modèle" />
<meta property="og:locale" content="fr-FR" />
<meta property="og:url" content="https://blog.pagesd.info/nerddinner/construire-modele/" />
<meta property="og:site_name" content="blog.pagesd.info" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2009-11-25T06:33:00.000Z" />
<script type="application/ld+json">{"headline":"blog.pagesd.info","dateModified":"2009-11-25T06:33:00.000Z","datePublished":"2009-11-25T06:33:00.000Z","inLanguage":"fr-FR","url":"https://blog.pagesd.info/nerddinner/construire-modele/","@type":"BlogPosting","image":"","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.pagesd.info/nerddinner/construire-modele/"},"author":{"@type":"Person","name":"Michel"},"@context":"https://schema.org"}</script>
  </head>

  <body><div class="container">

    <header><nav>
      <a class="title" href="/">blog.pagesd.info</a>
      // <a href="/archives/">archives</a>
      // <a href="/traductions/">traductions</a>
    </nav></header>

<article>



  <header>
    <h1>
      <a href="">NerdDinner(fr) : Construire le modèle</a>
    </h1>
    <p>
      <span>2009-11-25</span>
    </p>
  </header>

  <div>

<p>Dans le cas d'un framework Model-View-Controller, le terme &quot;Modèle&quot; fait
référence aux objets qui représentent les données de l'application, ainsi qu'à
la logique du domaine correspondant qui comprend la validation des données et
les règles métiers associées. À bien des égards, le modèle est le &quot;cœur&quot; d'une
application MVC, et comme nous le verrons plus tard détermine sa façon de
fonctionner.</p>
<p>Le framework ASP.NET MVC prend en charge toutes les techniques d'accès aux
données, et les développeurs peuvent mettre en œuvre leur modèle à partir d'un
large éventail de solutions : LINQ to Entities, LINQ to SQL, NHibernate, LLBLGen
Pro, SubSonic, WilsonORM, ou tout simplement des DataReader ou des DataSet.</p>
<p>Pour notre application NerdDinner nous utiliserons LINQ to SQL pour créer un
simple modèle de domaine qui correspond d'assez près au modèle physique de
notre base de données et ajoute une dose de logique de validation et de règles
métiers. Nous réaliserons aussi une classe Repository qui nous permettra de
bien séparer la gestion de la persistance des données du reste de l'application
et simplifiera la réalisation de tests unitaires.</p>
<h2>LINQ to SQL</h2>
<p>LINQ to SQL est un ORM (un mapping objet-relationnel) qui fait parti de
ASP.NET 3.5.</p>
<p>LINQ to SQL fournit une méthode simple pour représenter les tables de la
base de données sous forme de classes .NET que nous pouvons utiliser pour
coder. Dans le cas de notre application NerdDinner, nous allons l'utiliser pour
faire correspondre les tables Dinners et RSVP de notre base de données avec des
classes Dinner et RSVP. Les colonnes des tables Dinners et RSVP correspondront
aux propriétés des classes Dinner et RSVP. Chaque objet Dinner ou RSVP
représentera une ligne distincte dans les tables Dinners ou RSVP de la base de
données.</p>
<p>LINQ to SQL nous permet d'éviter d'avoir à écrire des requêtes SQL à la main
pour retrouver et initialiser les objets Dinner et RSVP à partir des données de
la base de données. Au lieu de cela, nous définissons les classes Dinner et
RSVP, la façon dont elles correspondent avec la base de données, et les
relations entre elles. Au moment de l'exécution, LINQ to SQL se charge de
générer les requêtes SQL nécessaires lorsque nous utilisons les classes Dinner
et RSVP.</p>
<p>Nous pouvons écrire des requêtes LINQ en VB ou C# pour retrouver les objets
Dinner et RSVP. Cela diminue la quantité de code spécifique aux données que
nous devons écrire, ce qui nous permet de construire des applications de
meilleure qualité.</p>
<h2>Ajout des classes LINQ to SQL à notre projet</h2>
<p>On commence par un clic droit sur le dossier &quot;Models&quot; de notre projet avant
de sélectionner la commande <strong>Add -&gt; New Item</strong> :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image041.png" alt=""></p>
<p>Cela fait apparaître la boite de dialogue &quot;Add New Item&quot; dans laquelle nous
choisissons la catégorie &quot;Data&quot; puis le modèle &quot;LINK to SQL Classes&quot; :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image042.png" alt=""></p>
<p>On donne le nom &quot;NerdDinner&quot; à notre classe puis on clique sur le bouton
&quot;Add&quot;. Visual Studio ajoute alors un fichier NedrDinner.dbml dans le dossier
\Models puis ouvre celui-ci dans le Concepteur Objet/Relationnel LINQ to
SQL :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image043.png" alt=""></p>
<h2>Création de classes de modèle de données avec LINQ to SQL</h2>
<p>LINQ to SQL permet de créer rapidement des classes de données à partir du
schéma d'une base de données existante. Pour cela, nous ouvrons la base de
données NerdDinner dans l'explorateur de serveur pour y sélectionner les tables
que nous voulons y voir figurer :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image044.png" alt=""></p>
<p>On fait alors glisser nos deux tables vers le concepteur LINQ to SQL. En
faisant cela, LINQ to SQL crée automatiquement les classes Dinner et RSVP en se
basant sur la structure des tables Dinners et RSVP (en reprenant comme
propriété de chaque classe les colonnes de la table correspondante) :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image045.png" alt=""></p>
<p>Par défaut, le concepteur LINQ to SQL met automatiquement au singulier les
noms des tables et des colonnes lorsqu'il crée des classes à partir d'un schéma
de base de données. Dans notre cas, la table &quot;Dinners&quot; de l'exemple ci-dessus
donne lieu à la classe &quot;Dinner&quot;. Cette méthode de nommage permet de rester
compatible avec les conventions de nommage de .NET et je trouve assez pratique
que le concepteur LINQ to SQL fonctionne comme cela (particulièrement lorsque
je dois ajouter un grand nombre de tables). Toutefois, si vous n'aimez pas le
nom généré pour une table ou une colonne, vous pouvez toujours revenir dessus
et le remplacer par le nom que vous voulez. Cela est possible soit en modifiant
le nom de l'entité / propriété dans le concepteur, soit en passant par la
grille des propriétés.</p>
<p>Par défaut, le concepteur LINQ to SQL inspecte également les relations clé
primaire / clé étrangère des tables et à partir de celles-ci génère
automatiquement des &quot;associations relationnelles&quot; entre les différentes classes
qu'il a créé. Par exemple, lorsque nous avons fait glisser les tables Dinners
et RSVP vers le concepteur LINQ to SQL, le fait que la table RSVP possède une
clé étrangère vers la table Dinners lui a permis d'en déduire une relation
un-à-plusieurs entre les deux (qui est représentée par la flèche dans le
concepteur) :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image046.png" alt=""></p>
<p>L'association ci-dessus va faire que LINQ to SQL ajoute une propriété
&quot;Dinner&quot; fortement typée à la classe RSVP que les développeurs pourront
employer pour accéder à l'entité &quot;Dinner&quot; associée à un objet RSVP donné. Cela
a  également pour effet d'ajouter une propriété collection &quot;RSVPs&quot;
fortement typée à la classe Dinner qui là aussi permettra aux développeurs de
retrouver et de mettre à jour les objets RSVP associés à ce dîner.</p>
<p>Ci-dessous vous pouvez voir un exemple d'IntelliSense dans Visual Studio
lorsque nous créons un nouvel objet RSVP et que nous l'ajoutons à la collection
RSVPs d'un objet Dinner :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image047.png" alt=""></p>
<p>Vous pouvez voir que LINQ to SQL a créé une collection &quot;RSVPs&quot; pour l'objet
Dinner. Nous pouvons l'employer pour associer une relation de clé étrangère
entre une ligne Dinner et une ligne RSVP dans notre base de données :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image048.png" alt=""></p>
<p>Si vous n'aimez pas la façon dont le concepteur a modélisé ou nommé une
association de table, vous pouvez aussi revenir dessus. Il suffit de cliquer
sur la flèche représentant l'association dans le concepteur et d'accéder à ses
propriétés via la grille de propriétés pour la renommer, la supprimer ou la
modifier. Mais dans le cas de notre application NerdDinner les règles
d'association par défaut fonctionnent bien par rapport au modèle de données de
classes que nous réalisons et nous pouvons donc conserver le comportement par
défaut.</p>
<h2>La classe NerdDinnerDataContext</h2>
<p>Visual Studio génère automatiquement des classes .NET qui représentent le
modèle et les relations de la base de données définie avec le concepteur LINQ
to SQL. Une classe DataContext est également générée pour chaque fichier LINQ
to SQL ajouté à la solution. Étant donné que notre classe LINQ to SQL s'appelle
&quot;NerdDinner&quot;, la classe DataContext créée se nomme &quot;NerdDinnerDataContext&quot;.
Cette classe NerdDinnerDataContext va constituer la méthode principale pour
interagir avec la base de données.</p>
<p>Dans notre cas, la classe NerdDinnerDataContext expose deux propriétés
&quot;Dinners&quot; et &quot;RSVPs&quot; qui représentent les deux tables que nous avons modélisées
dans notre base de données. Nous pouvons utiliser le langage C# pour écrire des
requêtes LINQ utilisant ces deux propriétés pour sélectionner et retrouver des
objets Dinner et RSVP à partir de la base de données.</p>
<p>Le code suivant montre comment instancier un objet NerdDinnerDataContext et
effectuer une requête LINQ sur celui-ci pour retrouver les dîners qui vont
bientôt se dérouler :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image049.png" alt=""></p>
<p>Un objet NerdDinnerDataContext garde la trace de toutes les modifications
apportées aux objets Dinner et RSVP récupérés par son intermédiaire et
simplifie leur enregistrement dans la base de données. Le code ci-dessous
illustre la façon dont on peut utiliser une requête LINQ pour obtenir  un
objet Dinner particulier de la base de données, mettre à jour deux de ses
propriétés, puis enregistrer ces modifications dans la base de données :</p>
<pre><code>NerdDinnerDataContext db = new NerdDinnerDataContext();

// Retrieve Dinner object that reprents row with DinnerID of 1
Dinner dinner = db.Dinners.Single(d =&gt; d.DinnerID == 1);

// Update two properties on Dinner
dinner.Title = &quot;Changed Title&quot;;
dinner.Description = &quot;This dinner will be fun&quot;;

// Persist changes to database
db.SubmitChanges();
</code></pre>
<p>Dans le code ci-dessus, l'objet NerdDinnerDataContext conserve
automatiquement la trace des modifications apportées à l'objet Dinner qu'il
nous a permis de retrouver. Quand nous appelons la méthode &quot;SubmitChanges()&quot;,
elle exécute la commande SQL &quot;UPDATE&quot; qui va bien pour sauvegarder les
modifications dans la base de données.</p>
<h2>Création d'une classe DinnerRepository</h2>
<p>Pour de petites applications, ce n'est pas bien gênant que les contrôleurs
attaquent directement les classes DataContext de LINQ to SQL et que les
requêtes LINQ soient codées directement à l'intérieur des contrôleurs. Mais
lorsque les applications grossissent, cela commence à devenir de plus en plus
difficile à maintenir et à tester. Et cela peut nous amener à répéter les mêmes
requêtes LINQ à plusieurs endroits dans l'application.</p>
<p>L'utilisation du modèle de conception (pattern) &quot;Repository&quot; rend les
applications plus faciles à maintenir et à tester. Une classe repository permet
d'encapsuler la recherche et l'enregistrement des données et par conséquent de
masquer complètement la façon de mettre en œuvre tout ce qui touche à la
persistance des données. En plus d'avoir un code plus propre, le fait
d'implémenter le pattern repository nous rend plus autonomes par rapport à la
façon dont sont stockées nos données. Et cela peut aussi simplifier les tests
unitaires de l'application en évitant l'utilisation d'une vraie base de
données.</p>
<p>Pour notre application, nous allons définir une classe DinnerRepository avec
la signature suivante :</p>
<pre><code>public class DinnerRepository {

   // Query Methods
   public IQueryable&lt;Dinner&gt; FindAllDinners();
   public IQueryable&lt;Dinner&gt; FindUpcomingDinners();
   public Dinner GetDinner(int id);

   // Insert/Delete
   public void Add(Dinner dinner);
   public void Delete(Dinner dinner);

   // Persistence
   public void Save();

}
</code></pre>
<p>''Note : plus loin dans ce chapitre, nous génèrerons une interface
IDinnerRepository à partir de cette classe pour adopter l'injection de
dépendance dans nos contrôleurs. Mais pour l'instant, nous allons au plus
simple en travaillant directement avec la classe DinnerRepository.''</p>
<p>Pour implémenter cette classe, on fait un clic-droit sur le dossier &quot;Models&quot;
et on choisi la commande <strong>Add -&gt; New Item</strong>. Dans la boite de
dialogue &quot;Add New Item&quot;, nous sélectionnons le modèle &quot;Class&quot; et donnons le nom
de &quot;DinnerRepository.cs&quot; à notre fichier :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image050.png" alt=""></p>
<p>Nous pouvons créer notre classe DinnerRespository en recopiant le code
ci-dessous :</p>
<pre><code>public class DinnerRepository {

   private NerdDinnerDataContext db = new NerdDinnerDataContext();

   //
   // Query Methods
   public IQueryable&lt;Dinner&gt; FindAllDinners() {
     return db.Dinners;
   }

   public IQueryable&lt;Dinner&gt; FindUpcomingDinners() {
     return from dinner in db.Dinners
             where dinner.EventDate &gt; DateTime.Now
             orderby dinner.EventDate
             select dinner;
   }

   public Dinner GetDinner(int id) {
     return db.Dinners.SingleOrDefault(d =&gt; d.DinnerID == id);
   }

   //
   // Insert/Delete Methods
   public void Add(Dinner dinner) {
     db.Dinners.InsertOnSubmit(dinner);
   }

   public void Delete(Dinner dinner) {
     db.RSVPs.DeleteAllOnSubmit(dinner.RSVPs);
     db.Dinners.DeleteOnSubmit(dinner);
   }

   //
   // Persistence
   public void Save() {
     db.SubmitChanges();
   }
}
</code></pre>
<h2>Utilisation de la classe DinnerRepository</h2>
<p>Maintenant que nous avons créé notre classe DinnerRepository, jetons un coup
d'œil à quelques exemples de code pour comprendre à quoi elle va pouvoir nous
servir :</p>
<h3>Exemple de recherche</h3>
<p>Le code ci-dessous retrouve un dîner particulier à partir de la valeur de
DinnerID :</p>
<pre><code>DinnerRepository dinnerRepository = new DinnerRepository();

// Retrieve specific dinner by its DinnerID
Dinner dinner = dinnerRepository.GetDinner(5);
</code></pre>
<p>Le code ci-dessous retrouve tous les dîners à venir puis fait une boucle sur
ceux-ci :</p>
<pre><code>DinnerRepository dinnerRepository = new DinnerRepository();

// Retrieve all upcoming Dinners
var upcomingDinners = dinnerRepository.FindUpcomingDinners();

// Loop over each upcoming Dinner
foreach (Dinner dinner in upcomingDinners) {

}
</code></pre>
<h3>Exemples d'insertion et de modification</h3>
<p>Le code ci-dessous illustre la façon d'ajouter deux nouveaux dîners. Les
ajouts et les modifications dans le repository ne sont pas répercutés dans la
base de données tant que la méthode &quot;Save()&quot; n'est pas appelée. LINQ to SQL
englobe automatiquement toutes les modifications de la base de données dans une
transaction. Ainsi, lorsque le repository est sauvegardé, soit toutes les mises
à jour sont effectuées, soit aucune :</p>
<pre><code>DinnerRepository dinnerRepository = new DinnerRepository();

// Create First Dinner
Dinner newDinner1 = new Dinner();
newDinner1.Title = &quot;Dinner with Scott&quot;;
newDinner1.HostedBy = &quot;ScotGu&quot;;
newDinner1.ContactPhone = &quot;425-703-8072&quot;;

// Create Second Dinner
Dinner newDinner2 = new Dinner();
newDinner2.Title = &quot;Dinner with Bill&quot;;
newDinner2.HostedBy = &quot;BillG&quot;;
newDinner2.ContactPhone = &quot;425-555-5151&quot;;

// Add Dinners to Repository
dinnerRepository.Add(newDinner1);
dinnerRepository.Add(newDinner2);

// Persist Changes
dinnerRepository.Save();
</code></pre>
<p>Le code ci-dessous extrait un objet Dinner puis modifie deux de ses
propriétés. Les changements apportées sont répercutés dans la base de données
lorsque la méthode &quot;Save()&quot; du repository est appelée :</p>
<pre><code>DinnerRepository dinnerRepository = new DinnerRepository();

// Retrieve specific dinner by its DinnerID
Dinner dinner = dinnerRepository.GetDinner(5);

// Update Dinner properties
dinner.Title = &quot;Update Title&quot;;
dinner.HostedBy = &quot;New Owner&quot;;

// Persist changes
dinnerRepository.Save();
</code></pre>
<p>Le code ci-dessous charge un dîner puis lui ajoute une réponse RSVP. Ceci
est réalisé en utilisant la collection RSVPs de l'objet Dinner que LINQ to SQL
a créé pour nous (grâce à la relation clé primaire / clé étrangère qui existe
dans la base de données). Cette modification est sauvegardée dans la base de
données sous la forme d'une nouvelle ligne dans la table RSVP quand on appelle
la méthode &quot;Save()&quot; de notre repository :</p>
<pre><code>DinnerRepository dinnerRepository = new DinnerRepository();

// Retrieve specific dinner by its DinnerID
Dinner dinner = dinnerRepository.GetDinner(5);

// Create a new RSVP object
RSVP myRSVP = new RSVP();
myRSVP.AttendeeName = &quot;ScottGu&quot;;

// Add RSVP to Dinner's RSVP Collection
dinner.RSVPs.Add(myRSVP);

// Persist changes
dinnerRepository.Save();
</code></pre>
<h3>Exemple de suppression</h3>
<p>Le code ci-dessous retrouve un objet Dinner particulier puis le supprime du
repository. Par la suite, lorsque la méthode &quot;Save()&quot; est appelée, la
suppression devient effective au niveau de la base de données :</p>
<pre><code>DinnerRepository dinnerRepository = new DinnerRepository();

// Retrieve specific dinner by its DinnerID
Dinner dinner = dinnerRepository.GetDinner(5);

// Mark dinner to be deleted
dinnerRepository.Delete(dinner);

// Persist changes
dinnerRepository.Save();
</code></pre>
<h2>Ajout du contrôle des données et de règles métiers à nos classes</h2>
<p>Le fait de valider les données et d'appliquer des règles métiers est un
aspect essentiel dès lors que l'on développe des applications qui traitent des
données.</p>
<h3>Validation du schéma</h3>
<p>Lorsque le concepteur LINQ to SQL a généré les classes modèles, il a calqué
le type de données des propriétés de ces classes sur celui des colonnes de la
base de données. Par exemple, si la colonne &quot;EventDate&quot; de la table &quot;Dinners&quot;
est de type &quot;DateTime&quot;, alors la propriété générée par LINQ to SQL sera de type
&quot;DateTime&quot; (qui est un type de données prédéfini du .NET framework). Cela
signifie que vous obtiendrez une erreur de compilation si vous écrivez du code
qui lui affecte directement un entier ou un booléen. De même, vous provoquerez
une erreur d'exécution si vous tentez de lui assigner une chaîne de type
incorrect au moment de l'exécution.</p>
<p>LINQ toSQL se charge également de gérer l'échappement des valeurs SQL
lorsque vous manipulez des chaînes, ce qui fait que vous n'avez pas à vous
préoccuper des risques d'attaque par injection SQL lorsque vous passez par
lui.</p>
<h3>Validation des données et règles métiers</h3>
<p>La validation par rapport au type de données est déjà un bon début, mais
c'est rarement suffisant. Dans la vrai vie, il est nécessaire d'en passer par
des règles de validation plus poussées : pouvoir tenir compte de plusieurs
propriétés, exécuter un bout de code, savoir ce que l'on est en train de faire
(par exemple, est-ce qu'on est en mode création, modification ou suppression ou
bien dans un cas spécifique à l'application comme un archivage ?).</p>
<p>Il y a un grand nombre de frameworks et de modèles de conceptions différents
qui peuvent être employés pour définir et appliquer des règles de validation à
des classes modèles. Il en existe plusieurs pour le framework .NET et vous
pouvez quasiment utiliser n'importe lequel d'entre eux dans le cadre d'une
application ASP.NET MVC.</p>
<p>Pour les besoins de notre application NerdDinner, notre choix va se porter
sur un modèle de conception relativement simple et direct qui consiste à
ajouter une propriété IsValid et une méthode GetRuleViolations() à notre objet
Dinner. La propriété IsValid renvoie true ou false selon que les règles de
validation sont toutes vérifiées ou non. La méthode GetRuleViolations() renvoie
la liste de toutes les règles en erreur.</p>
<p>Nous allons ajouter une &quot;classe partielle&quot; à notre projet pour définir
IsValid et GetRuleViolations(). On peut utiliser les classes partielles pour
ajouter des méthodes, des propriétés ou des évènements à des classes gérées par
un concepteur de Visual Studio (c'est le cas de notre classe Dinner qui a été
générée par le concepteur LINQ to SQL) de façon à ne pas le perturber avec du
code saisi manuellement dans la classe d'origine.</p>
<p>Pour ajouter une nouvelle classe partielle au projet, nous faisons un
clic-droit sur le dossier \Models puis choisissons la commande &quot;Add New Item&quot;
pour faire apparaitre la boite de dialogue du même nom. Nous pouvons alors
sélectionner le modèle &quot;Class&quot; et saisir le nom &quot;Dinner.cs&quot; :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image051.png" alt=""></p>
<p>En cliquant sur le bouton &quot;Add&quot;, le fichier Dinner.cs est ajouté au projet
puis ouvert dans l'éditeur de code. Nous pouvons alors écrire un squelette de
règles et validations de base en y copiant le code ci-dessous :</p>
<pre><code>public partial class Dinner {

   public bool IsValid {
     get { return (GetRuleViolations().Count() == 0); }
   }

   public IEnumerable&lt;RuleViolation&gt; GetRuleViolations() {
     yield break;
   }

   partial void OnValidate(ChangeAction action) {
     if (!IsValid)
        throw new ApplicationException(&quot;Rule violations prevent saving&quot;);
   }
}

public class RuleViolation {

   public string ErrorMessage { get; private set; }
   public string PropertyName { get; private set; }

   public RuleViolation(string errorMessage) {
     ErrorMessage = errorMessage;
   }

   public RuleViolation(string errorMessage, string propertyName) {
     ErrorMessage = errorMessage;
     PropertyName = propertyName;
   }
}
</code></pre>
<p>Quelques explications sur ce code :</p>
<ul>
<li>La classe Dinner est précédée du mot clé &quot;partial&quot;, ce qui signifie que le
code qu'elle contient sera combiné avec celui de la classe générée / maintenue
par le concepteur LINQ to SQL avant d'être compilé en une seule classe</li>
<li>L'invocation de la méthode GetRuleViolations() provoque la vérification de
nos règles de validation métier (qu'il nous reste à coder). La méthode
GetRuleViolations() renvoie une série d'objets RuleViolation qui détaillent
chaque erreur rencontrée.</li>
<li>La propriété IsValid nous fourni une méthode simple pour savoir si l'objet
Dinner ne respecte pas certaines règles de validation. Elle peut être contrôlée
à tout moment à l'initiative du développeur (et ce sans renvoyer
d'exception).</li>
<li>La méthode partielle OnValidate() nous permet d'être notifié par LINQ to
SQL chaque fois que l'objet Dinner est sur le point d'être sauvegardé dans la
base de données. Telle que nous l'avons programmée ci-dessus, notre méthode
OnValidate() s'assure que l'objet Dinner ne viole aucune règle avant qu'il soit
enregistré. Si c'est le cas, elle soulève une exception qui aura pour effet
d'annuler la transaction LINQ to SQL en cours.</li>
</ul>
<p>Cette approche nous fourni un modèle dans lequel nous pouvons intégrer nos
contrôles de validité et nos règles métiers. Pour l'instant, nous allons
ajouter les règles suivantes à notre méthode GetRuleViolations() :</p>
<pre><code>public IEnumerable&lt;RuleViolation&gt; GetRuleViolations() {

   if (String.IsNullOrEmpty(Title))
     yield return new RuleViolation(&quot;Title required&quot;, &quot;Title&quot;);

   if (String.IsNullOrEmpty(Description))
     yield return new RuleViolation(&quot;Description required&quot;, &quot;Description&quot;);

   if (String.IsNullOrEmpty(HostedBy))
     yield return new RuleViolation(&quot;HostedBy required&quot;, &quot;HostedBy&quot;);

   if (String.IsNullOrEmpty(Address))
     yield return new RuleViolation(&quot;Address required&quot;, &quot;Address&quot;);

   if (String.IsNullOrEmpty(Country))
     yield return new RuleViolation(&quot;Country required&quot;, &quot;Address&quot;);

   if (String.IsNullOrEmpty(ContactPhone))
     yield return new RuleViolation(&quot;Phone# required&quot;, &quot;ContactPhone&quot;);

   if (!PhoneValidator.IsValidNumber(ContactPhone, Country))
     yield return new RuleViolation(&quot;Phone# does not match country&quot;,
                                        &quot;ContactPhone&quot;);
   yield break;
}
</code></pre>
<p>Nous utilisons la fonctionnalité &quot;yield return&quot; du C# pour pouvoir renvoyer
une série avec toutes les RuleViolations. Les six premières règles programmées
ci-dessus vérifient simplement que les propriétés de type chaînes de notre
objet Dinner ne sont pas vides ou nulles. La dernière règle est un peu plus
intéressante et fait appel à une méthode PhoneValidator.IsValidNumber() que
nous allons aussi ajouter à notre projet pour contrôler que le numéro de
téléphone ContactPhone respecte le format des numéros de téléphone du pays où
est organisé le dîner.</p>
<p>Nous allons utiliser les expressions régulières pour effectuer ce contrôle
de format. Nous pouvons ajouter le code ci-dessous à notre projet pour gérer
des règles de validation spécifique selon le pays :</p>
<pre><code>public class PhoneValidator {

   static IDictionary&lt;string, Regex&gt; countryRegex =
                                           new Dictionary&lt;string, Regex&gt;() {
        { &quot;USA&quot;, new Regex(&quot;^[2-9]\\d{2}-\\d{3}-\\d{4}$&quot;)},
        { &quot;UK&quot;, new
Regex(&quot;(^1300\\d{6}$)|(^1800|1900|1902\\d{6}$)|(^0[2|3|7|8]{1}[0-
9]{8}$)|(^13\\d{4}$)|(^04\\d{2,3}\\d{6}$)&quot;)},
        { &quot;Netherlands&quot;, new Regex(&quot; (^\\+[0-9]{2}|^\\+[0-
9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-
\\s]{10}$)&quot;)},
   };

   public static bool IsValidNumber(string phoneNumber, string country) {
     if (country != null &amp;&amp; countryRegex.ContainsKey(country))
        return countryRegex[country].IsMatch(phoneNumber);
     else
        return false;
   }

   public static IEnumerable&lt;string&gt; Countries {
     get {
        return countryRegex.Keys;
     }
   }
}
</code></pre>
<p>Désormais, lorsque nous essayons de créer ou de mettre à jour un dîner, nos
règles de validation logiques sont appliquées automatiquement. Il nous est
possible de les vérifier de nous même et de récupérer la liste de toutes les
règles non respectées sans que cela soulève d'exception :</p>
<pre><code>Dinner dinner = dinnerRepository.GetDinner(5);

dinner.Country = &quot;USA&quot;;
dinner.ContactPhone = &quot;425-555-BOGUS&quot;;

if (!dinner.IsValid) {

   var errors = dinner.GetRuleViolations();

   // do something to fix errors
}
</code></pre>
<p>Si nous faisons en sorte qu'un dîner ne soit pas valide, une exception est
levée lorsque nous appelons la méthode Save() de notre classe DinnerRepository.
Cela se produit parce que notre méthode partielle OnValidate() soulève une
exception dès lors qu'au moins une règle n'est pas respectée. Nous pouvons
intercepter cette exception pour récupérer une liste des problèmes à
corriger :</p>
<pre><code>Dinner dinner = dinnerRepository.GetDinner(5);

try {
   dinner.Country = &quot;USA&quot;;
   dinner.ContactPhone = &quot;425-555-BOGUS&quot;;

   dinnerRepository.Save();
}
catch {

   var errors = dinner.GetRuleViolations();

   // do something to fix errors
}
</code></pre>
<p>Étant donné que nos contrôles de validité et nos règles métiers sont
programmés dans notre couche modèle, et pas dans la partie interface
utilisateur, ils sont appliqués et pris en compte dans tous les cas de figure.
Si par la suite nous modifions ou ajoutons certaines règles de validation, tout
le code qui travaille avec des objets Dinner en tiendra immédiatement compte.
Le fait d'avoir la possibilité de mettre à jour ces règles à un seul endroit,
sans avoir à les répercuter dans tous les sources de l'application et dans les
différents recoins de l'interface utilisateur, est la marque d'une application
bien conçue et c'est un point sur lequel le framework MVC nous aide à
progresser.</p>
<hr>
<p>Index : <a href="http://tinyurl.com/NerdDinnerFR">NerdDinner en français</a> - Suite : <a href="/nerddinner/controleurs-vues/">Contrôleurs et Vues</a></p>


  </div>

</article>


    <footer>
      <a href="/">blog.pagesd.info</a> ///
      <a href="https://www.solitaire-play.com/">www.solitaire-play.com</a>
    </footer>

  </div></body>

</html>

<!doctype html>
<html lang="fr-FR">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>NerdDinner(fr) : Ajouter une carte en Ajax - blog.pagesd.info</title>
    <link rel="shortcut icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" href="/atom.xml" title="blog.pagesd.info" type="application/atom+xml">
    <a rel="me" href="https://pouet.chapril.org/@ms_michel">Mastodon</a>
    <meta name="author" content="Michel" />
<link rel="canonical" href="https://blog.pagesd.info/nerddinner/ajouter-carte-ajax/" />
<meta property="og:title" content="NerdDinner(fr) : Ajouter une carte en Ajax" />
<meta property="og:locale" content="fr-FR" />
<meta property="og:url" content="https://blog.pagesd.info/nerddinner/ajouter-carte-ajax/" />
<meta property="og:site_name" content="blog.pagesd.info" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2010-02-01T16:33:00.000Z" />
<script type="application/ld+json">{"headline":"blog.pagesd.info","dateModified":"2010-02-01T16:33:00.000Z","datePublished":"2010-02-01T16:33:00.000Z","inLanguage":"fr-FR","url":"https://blog.pagesd.info/nerddinner/ajouter-carte-ajax/","@type":"BlogPosting","image":"","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.pagesd.info/nerddinner/ajouter-carte-ajax/"},"author":{"@type":"Person","name":"Michel"},"@context":"https://schema.org"}</script>
  </head>

  <body><div class="container">

    <header><nav>
      <a class="title" href="/">blog.pagesd.info</a>
      // <a href="/archives/">archives</a>
      // <a href="/traductions/">traductions</a>
    </nav></header>

<article>



  <header>
    <h1>
      <a href="">NerdDinner(fr) : Ajouter une carte en Ajax</a>
    </h1>
    <p>
      <span>2010-02-01</span>
    </p>
  </header>

  <div>

<p>Nous allons maintenant rendre notre application encore un peu plus sexy en
utilisant à nouveau un traitement en Ajax pour afficher une carte. Grâce à
celle-ci, la personne qui veut créer un dîner, le modifier ou simplement le
consulter aura la possibilité de visualiser graphiquement l'endroit où celui-ci
va avoir lieu.</p>
<h2>Créer une vue partielle Map.ascx</h2>
<p>Nous utiliserons ce système de carte dans plusieurs parties de notre
application. Pour que notre code reste fidèle au principe DRY, nous allons
regrouper les fonctionnalités communes de cette carte dans une vue partielle
unique que nous pourrons réutiliser à partir de plusieurs actions et vues. Nous
allons donc créer une vue partielle nommée &quot;Map.ascx&quot; dans le répertoire
\Views\Dinners.</p>
<p>Pour cela, nous devons faire un clic-droit dans le dossier \Views\Dinners et
sélectionner la commande Add-&gt;View dans le menu qui apparait. Il faut
ensuite saisir le nom &quot;Map.ascx&quot;, cocher pour créer une vue partielle et
indiquer que nous voulons créer une vue basée sur la classe &quot;Dinners&quot; :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image127.png" alt=""></p>
<p>La vue partielle est créée après avoir cliqué sur le bouton &quot;Add&quot;. Il nous
suffit alors de modifier le contenu du fichier Map.ascx généré pour y reprendre
le code suivant :</p>
<pre><code>&lt;script src=&quot;http://dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=6.2&quot;
type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;/Scripts/Map.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;theMap&quot;&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

   $(document).ready(function() {
     var latitude = &lt;%= Model.Latitude %&gt;;
     var longitude = &lt;%= Model.Longitude %&gt;;
     if ((latitude == 0) || (longitude == 0))
        LoadMap();
     else
        LoadMap(latitude, longitude, mapLoaded);
   });

   function mapLoaded() {
     var title = &quot;&lt;%= Html.Encode(Model.Title) %&gt;&quot;;
     var address = &quot;&lt;%= Html.Encode(Model.Address) %&gt;&quot;;
     LoadPin(center, title, address);
     map.SetZoomLevel(14);
   }
&lt;/script&gt;
</code></pre>
<p>Le premier &lt;script&gt; fait référence à la librairie JavaScript de
Microsoft Virtual Earth 6.2. Le second &lt;script&gt; sert à charger un fichier
&quot;Map.js&quot; que nous allons créer par la suite pour regrouper tous les traitements
nécessaires à la réalisation de notre carte. L'élément &lt;div id=&quot;theMap&quot;&gt;
va servir pour contenir la carte générée par Virtual Earth.</p>
<p>Nous avons ensuite un bloc &lt;script&gt; qui contient deux fonctions
JavaScript écrites spécialement pour notre vue partielle. La première de ces
fonctions utilise jQuery pour définir un traitement qui s'exécutera dès que le
chargement de la page sera terminé. Elle appelle une fonction LoadMap() que
nous programmerons bientôt dans le fichier Map.js pour charger une carte
Virtual Earth. La seconde fonction est une fonction callback qui sert pour
afficher une punaise sur le plan afin de marquer l'emplacement d'un dîner.</p>
<p>Vous pouvez voir que nous avons utilisé des blocs de code serveur &lt;%=
%&gt; à l'intérieur du JavaScript côté client pour indiquer la latitude et la
longitude du dîner que nous voulons faire apparaitre sur la carte. C'est une
technique très pratique pour générer des valeurs dynamiques dont nous avons
besoin au niveau des scripts clients (sans pour cela nécessiter une requête
Ajax supplémentaire pour récupérer ces valeurs, ce qui serait plus lent). Les
blocs &lt;%= %&gt; s'exécutent lorsque la vue est générée par le serveur - et
par conséquent le HTML final contient bien les valeurs attendues par le
JavaScript (par exemple : var latitude = 47.64312).</p>
<p><strong>Note du traducteur :</strong> Cette méthode présente un problème au
niveau du séparateur décimal sur les systèmes en français : JavaScript attend un
&quot;.&quot; quelle que soit la culture du système alors que ASP.NET génère une &quot;,&quot; dans
le cadre des instructions &lt;%= Model.Latitude %&gt; et &lt;%= Model.Longitude
%&gt;. La solution la plus simple est de modifier la section <code>globalization</code>
dans le fichier web.config :</p>
<pre><code>&lt;configuration&gt;
   &lt;system.web&gt;
      &lt;globalization culture=&quot;en-US&quot; /&gt;
   &lt;/system.web&gt;
&lt;/configuration&gt;
</code></pre>
<p>(Source : <a href="http://nerddinner.codeplex.com/Thread/View.aspx?ThreadId=54102">http://nerddinner.codeplex.com/Thread/View.aspx?ThreadId=54102</a>)</p>
<h2>Créer un script Map.js</h2>
<p>Nous allons maintenant créer le fichier Map.js qui va nous servir à
regrouper toutes les fonctionnalités JavaScript de notre système de carte
(entre autre les fonctions LoadMap() et LoadPin() vues plus haut). Pour cela,
il suffit de faire un clic-droit dans le répertoire \Scripts depuis
l'explorateur de projet puis de choisir la commande &quot;Add-&gt;New Item&quot;. Nous
pouvons alors sélectionner le type de fichier &quot;JScript&quot; puis lui donner le nom
&quot;Map.js&quot;.</p>
<p>Nous ajoutons ensuite le code JavaScript ci-dessous à ce fichier Map.js afin
d'interagir avec Virtual Earth pour afficher notre carte et pouvoir placer des
punaises sur celle-ci pour repérer les dîners :</p>
<pre><code>var map = null;
var points = [];
var shapes = [];
var center = null;

function LoadMap(latitude, longitude, onMapLoaded) {
   map = new VEMap('theMap');
   options = new VEMapOptions();
   options.EnableBirdseye = false;

   // Makes the control bar less obtrusize.
   map.SetDashboardSize(VEDashboardSize.Small);

   if (onMapLoaded != null)
     map.onLoadMap = onMapLoaded;

   if (latitude != null &amp;&amp; longitude != null) {
     center = new VELatLong(latitude, longitude);
   }

   map.LoadMap(center, null, null, null, null, null, null, options);
}

function LoadPin(LL, name, description) {
   var shape = new VEShape(VEShapeType.Pushpin, LL);

   //Make a nice Pushpin shape with a title and description
   shape.SetTitle(&quot;&lt;span class=\&quot;pinTitle\&quot;&gt; &quot; + escape(name) + &quot;&lt;/span&gt;&quot;);
   if (description !== undefined) {
     shape.SetDescription(&quot;&lt;p class=\&quot;pinDetails\&quot;&gt;&quot; +
     escape(description) + &quot;&lt;/p&gt;&quot;);
   }
   map.AddShape(shape);
   points.push(LL);
   shapes.push(shape);
}

function FindAddressOnMap(where) {
   var numberOfResults = 20;
   var setBestMapView = true;
   var showResults = true;

   map.Find(&quot;&quot;, where, null, null, null,
                numberOfResults, showResults, true, true,
                setBestMapView, callbackForLocation);
}

function callbackForLocation(layer, resultsArray, places,
                                 hasMore, VEErrorMessage) {
   clearMap();

   if (places == null)
     return;

   //Make a pushpin for each place we find
   $.each(places, function(i, item) {
     description = &quot;&quot;;
     if (item.Description !== undefined) {
        description = item.Description;
     }
     var LL = new VELatLong(item.LatLong.Latitude, item.LatLong.Longitude);
     LoadPin(LL, item.Name, description);
   });

   //Make sure all pushpins are visible
   if (points.length &gt; 1) {
     map.SetMapView(points);
   }

   //If we've found exactly one place, that's our address.
   if (points.length === 1) {
     $(&quot;#Latitude&quot;).val(points[0].Latitude);
     $(&quot;#Longitude&quot;).val(points[0].Longitude);
   }
}

function clearMap() {
   map.Clear();
   points = [];
   shapes = [];
}
</code></pre>
<h2>Afficher la carte dans les formulaires Edit et Create</h2>
<p>Nous allons maintenant faire apparaitre une carte lors de la création et de
la modification des dîners. La bonne nouvelle, c'est que ce n'est vraiment pas
compliqué à faire et que nous n'avons pas besoin de toucher au code de notre
contrôleur. L'interface utilisateur du formulaire de saisie des dîners est
commune aux vues Create et Edit étant donné qu'elles emploient toutes les deux
la vue partielle &quot;DinnerForm&quot;. Nous allons donc pouvoir ajouter notre carte à
un seul endroit et celle-ci sera prise en compte dans les deux scénarios Edit
et Create.</p>
<p>Tout ce que nous avons besoin de faire, c'est d'ouvrir la vue partielle
\Views\Dinners\DinnerForm.ascx et à la mettre à jour pour lui ajouter la vue
partielle &quot;Map.ascx&quot;. Vous pouvez voir ci-dessous à quoi ressemble le code de
DinnerForm une fois que la carte a été insérée (les éléments du formulaire
n'apparaissant pas pour rester suffisamment clair) :</p>
<pre><code>&lt;%= Html.ValidationSummary() %&gt;

&lt;% using (Html.BeginForm()) { %&gt;

   &lt;fieldset&gt;

     &lt;div id=&quot;dinnerDiv&quot;&gt;
        &lt;p&gt;
          [HTML Form Elements Removed for Brevity]
        &lt;/p&gt;
        &lt;p&gt;
           &lt;input type=&quot;submit&quot; value=&quot;Save&quot; /&gt;
        &lt;/p&gt;
     &lt;/div&gt;

     &lt;div id=&quot;mapDiv&quot;&gt;
        &lt;% Html.RenderPartial(&quot;Map&quot;, Model.Dinner); %&gt;
     &lt;/div&gt;

   &lt;/fieldset&gt;

   &lt;script type=&quot;text/javascript&quot;&gt;
     $(document).ready(function() {
        $(&quot;#Address&quot;).blur(function(evt) {
           $(&quot;#Latitude&quot;).val(&quot;&quot;);
           $(&quot;#Longitude&quot;).val(&quot;&quot;);

              var address = jQuery.trim($(&quot;#Address&quot;).val());
           if (address.length &lt; 1)
                return;

              FindAddressOnMap(address);
        });
     });

   &lt;/script&gt;

&lt;% } %&gt;
</code></pre>
<p>La vue partielle DinnerForm ci-dessus est basée sur un objet de type
&quot;DinnerFormViewModel&quot; (puisqu'elle a besoin à la fois d'un objet Dinner et
d'une SelectList pour remplir la liste des pays) alors que la vue partielle Map
a seulement besoin d'un objet de type &quot;Dinner&quot;. Par conséquent, nous nous
contentons de lui passer la propriété Dinner de l'objet DinnerFormViewModel
pour faire le rendu de la vue Map :</p>
<pre><code>&lt;% Html.RenderPartial(&quot;Map&quot;, Model.Dinner); %&gt;
</code></pre>
<p>La fonction JavaScript que nous avons ajoutée à la vue partielle utilise
jQuery pour attacher un évènement &quot;blur&quot; à la zone de saisie &quot;Address&quot;. Vous
avez probablement déjà entendu parler des évènements &quot;focus&quot; qui se produisent
lorsque l'utilisateur clique ou arrive sur une textbox. À l'opposé, l'évènement
&quot;blur&quot; se déclenche quand l'utilisateur sort de la textbox. Le gestionnaire
d'évènement ci-dessus efface le contenu des champs latitude et longitude
lorsque cela se produit puis indique le nouvel emplacement correspondant à
l'adresse sur le plan. Le gestionnaire d'évènement callback qui a été défini
dans le fichier Map.js va alors se charger de mettre à jour les champs latitude
et longitude de notre formulaire en utilisant pour cela les valeurs renvoyées
par Virtual Earth en fonction de l'adresse que nous lui avons transmise.</p>
<p>Et maintenant, quand nous relançons notre application, un clic sur l'onglet
&quot;Host Dinner&quot; affiche la carte par défaut en plus des champs de saisie
habituels d'un dîner :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image128.png" alt=""></p>
<p>Quand nous saisissons une adresse, puis que nous passons à la zone de saisie
suivante, la carte se met à jour de façon dynamique pour afficher l'emplacement
du dîner et notre gestionnaire d'évènement copie les coordonnées GPS du dîner
dans les zones latitude et longitude :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image129.png" alt=""></p>
<p>Si nous enregistrons ce nouveau dîner puis que nous revenons dessus pour le
mettre à jour, nous pouvons voir que l'emplacement du dîner est affiché sur la
carte au chargement de la page :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image130.png" alt=""></p>
<p>Chaque fois que nous modifions le contenu du champ adresse, la carte et les
deux zones latitude et longitude sont aussitôt mises à jour.</p>
<p>Maintenant que notre carte affiche l'emplacement du dîner, il n'est plus
nécessaire que les zones de saisie latitude et longitude soient visibles et
nous pouvons les transformer en champs cachés puisqu'elles seront mises à jour
automatiquement à chaque fois que l'adresse change. Pour cela, nous remplaçons
simplement le helper Html.TextBox() par le helper Html.Hidden() :</p>
<pre><code>&lt;p&gt;
   &lt;%= Html.Hidden(&quot;Latitude&quot;, Model.Dinner.Latitude)%&gt;
   &lt;%= Html.Hidden(&quot;Longitude&quot;, Model.Dinner.Longitude)%&gt;
&lt;/p&gt;
</code></pre>
<p>Cela rend nos formulaires un peu plus conviviaux puisque nous n'y faisons
plus apparaitre des informations purement techniques (tout en continuant à les
stocker dans la base de données) :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image131.png" alt=""></p>
<h2>Intégrer la carte à la vue Details</h2>
<p>Après avoir réussi à faire apparaitre la carte lorsque nous somme en
création ou en modification d'un dîner, nous allons aussi l'afficher lors de la
consultation d'un dîner. Tout ce que nous avons à faire c'est d'appeler &lt;%
Html.RenderPartial(&quot;map&quot;); %&gt; dans la vue Details :</p>
<p>Une fois la carte ajoutée, le code source complet de la vue Details sera le
suivant :</p>
<pre><code>&lt;asp:Content ID=&quot;Title&quot; ContentPlaceHolderID=&quot;TitleContent&quot; runat=&quot;server&quot;&gt;
   &lt;%= Html.Encode(Model.Title) %&gt;
&lt;/asp:Content&gt;

&lt;asp:Content ID=&quot;details&quot; ContentPlaceHolderID=&quot;MainContent&quot; runat=&quot;server&quot;&gt;

   &lt;div id=&quot;dinnerDiv&quot;&gt;

     &lt;h2&gt;&lt;%= Html.Encode(Model.Title) %&gt;&lt;/h2&gt;
     &lt;p&gt;
        &lt;strong&gt;When:&lt;/strong&gt;
        &lt;%= Model.EventDate.ToShortDateString() %&gt;
        &lt;strong&gt;@&lt;/strong&gt;
        &lt;%= Model.EventDate.ToShortTimeString() %&gt;
     &lt;/p&gt;
     &lt;p&gt;
        &lt;strong&gt;Where:&lt;/strong&gt;
        &lt;%= Html.Encode(Model.Address) %&gt;,
        &lt;%= Html.Encode(Model.Country) %&gt;
     &lt;/p&gt;
     &lt;p&gt;
        &lt;strong&gt;Description:&lt;/strong&gt;
        &lt;%= Html.Encode(Model.Description) %&gt;
     &lt;/p&gt;
     &lt;p&gt;
        &lt;strong&gt;Organizer:&lt;/strong&gt;
        &lt;%= Html.Encode(Model.HostedBy) %&gt;
        (&lt;%= Html.Encode(Model.ContactPhone) %&gt;)
     &lt;/p&gt;

     &lt;% Html.RenderPartial(&quot;RSVPStatus&quot;); %&gt;
     &lt;% Html.RenderPartial(&quot;EditAndDeleteLinks&quot;); %&gt;

   &lt;/div&gt;

   &lt;div id=&quot;mapDiv&quot;&gt;
     &lt;% Html.RenderPartial(&quot;map&quot;); %&gt;
   &lt;/div&gt;

&lt;/asp:Content&gt;
</code></pre>
<p>Et maintenant, lorsqu'un visiteur arrive sur une URL /Dinners/Details/[id],
il peut voir les informations concernant le dîner, l'emplacement du dîner sur
la carte (représenté par une punaise rouge qui permet d'afficher le titre du
dîner et son adresse lorsque la souris passe au-dessus) et il dispose d'un lien
Ajax pour s'inscrire à ce dîner :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image132.png" alt=""></p>
<h2>Ajouter la recherche d'emplacement dans la base et dans le repository</h2>
<p>Pour finaliser cette cartographie Ajax, nous allons ajouter une dernière
carte sur la page d'accueil de notre application. Celle-ci servira aux
visiteurs pour rechercher de façon graphique les dîners qui vont avoir lieu
dans leur région :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image133.png" alt=""></p>
<p>Pour implémenter au mieux cette recherche de dîners basée sur des
coordonnées géographiques, nous allons commencer par ajouter les fonctions
nécessaires au niveau de la base de données et de la couche repository de notre
application. Nous aurions pu utiliser les nouvelles fonctionnalités
géospatiales de SQL Server 2008 (<a href="http://www.microsoft.com/sqlserver/2008/en/us/spatial-data.aspx">http://www.microsoft.com/sqlserver/2008/en/us/spatial-data.aspx</a>), mais
nous allons employer la fonction SQL présentée par Gary Dryden dans l'article
<a href="http://www.codeproject.com/KB/cs/distancebetweenlocations.aspx">http://www.codeproject.com/KB/cs/distancebetweenlocations.aspx</a> que Rob
Conery a implémentée en utilisant LINQ to SQL (<a href="http://blog.wekeroad.com/2007/08/30/linq-andgeocoding/">http://blog.wekeroad.com/2007/08/30/linq-andgeocoding/</a>).</p>
<p>Pour mettre en œuvre cette méthode, nous devons ouvrir l'explorateur de
serveurs dans Visual Studio, y sélectionner la base de données NerdDinner,
faire un clic-droit sur sa branche &quot;Functions&quot; et demander à créer une nouvelle
&quot;Fonction scalaire&quot; :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image134.png" alt=""></p>
<p>Nous pouvons alors y coller la fonction DistanceBetween suivante :</p>
<pre><code>CREATE FUNCTION [dbo].[DistanceBetween] (@Lat1 as real,
                   @Long1 as real, @Lat2 as real, @Long2 as real)
RETURNS real
AS
BEGIN

DECLARE @dLat1InRad as float(53);
SET @dLat1InRad = @Lat1 * (PI()/180.0);
DECLARE @dLong1InRad as float(53);
SET @dLong1InRad = @Long1 * (PI()/180.0);
DECLARE @dLat2InRad as float(53);
SET @dLat2InRad = @Lat2 * (PI()/180.0);
DECLARE @dLong2InRad as float(53);
SET @dLong2InRad = @Long2 * (PI()/180.0);

DECLARE @dLongitude as float(53);
SET @dLongitude = @dLong2InRad - @dLong1InRad;
DECLARE @dLatitude as float(53);
SET @dLatitude = @dLat2InRad - @dLat1InRad;
/* Intermediate result a. */
DECLARE @a as float(53);
SET @a = SQUARE (SIN (@dLatitude / 2.0)) + COS (@dLat1InRad)
                   * COS (@dLat2InRad)
                   * SQUARE(SIN (@dLongitude / 2.0));
/* Intermediate result c (great circle distance in Radians). */
DECLARE @c as real;
SET @c = 2.0 * ATN2 (SQRT (@a), SQRT (1.0 - @a));
DECLARE @kEarthRadius as real;
/* SET kEarthRadius = 3956.0 miles */
SET @kEarthRadius = 6376.5; /* kms */

DECLARE @dDistance as real;
SET @dDistance = @kEarthRadius * @c;
return (@dDistance);
END
</code></pre>
<p>Puis nous créons une nouvelle &quot;Fonction table&quot; dans SQL Server que nous
appellerons &quot;NearestDinners&quot; :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image135.png" alt=""></p>
<p>Cette fonction table &quot;NearestDinners&quot; utilise la fonction helper
DistanceBetween pour renvoyer tous les dîners à moins de 100 miles des
coordonnées latitude / longitude que nous lui faisons passer :</p>
<pre><code>CREATE FUNCTION [dbo].[NearestDinners]
     (
     @lat real,
     @long real
     )
RETURNS TABLE
AS
     RETURN
     SELECT Dinners.DinnerID
     FROM Dinners
     WHERE dbo.DistanceBetween(@lat, @long, Latitude, Longitude) &lt;100
</code></pre>
<p>Pour appeler cette fonction, nous commençons par ouvrir le concepteur LINQ
to SQL en double-cliquant sur le fichier NerdDinner.dbml dans le répertoire
Models :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image136.png" alt=""></p>
<p>Puis nous déplaçons par drag and drop les fonctions NearestDinners et
DistanceBetween dans le concepteur LINQ to SQL ce qui a pour effet de les
ajouter en tant que méthode à la classe NerdDinnerDataContext générée par LINQ
to SQL :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image137.png" alt=""></p>
<p>Nous pouvons alors ajouter une méthode &quot;FindByLocation&quot; à notre classe
DinnerRepository qui va utiliser la fonction NearestDinner de la classe
NerdDinnerDataContext pour renvoyer les dîners à venir qui sont situés dans les
100 miles de l'emplacement spécifié :</p>
<pre><code>public IQueryable&lt;Dinner&gt; FindByLocation(float latitude, float longitude) {

   var dinners = from dinner in FindUpcomingDinners()
                   join i in db.NearestDinners(latitude, longitude)
                   on dinner.DinnerID equals i.DinnerID
                   select dinner;

   return dinners;
}
</code></pre>
<h2>Ajouter une action Ajax qui renvoie des données JSON</h2>
<p>Nous allons maintenant ajouter une nouvelle méthode d'action qui va
s'appuyer sur cette méthode FindByLocation() du repository pour renvoyer une
liste de données Dinner qui pourra être utilisée pour illustrer la carte. Nous
allons faire en sorte que cette méthode d'action renvoie les dîners au format
JSON (JavaScript Object Notation) afin qu'il soit facile de les manipuler en
JavaScript côté client.</p>
<p>Nous devons créer une nouvelle classe &quot;SearchController&quot; en faisant un
clic-droit dans le répertoire \Controllers et en choisissant la commende
Add-&gt;Controller. Puis nous pouvons ajouter une action &quot;SearchByLocation&quot;
dans ce contrôleur en y copiant le code ci-dessous :</p>
<pre><code>public class JsonDinner {
   public int DinnerID { get; set; }
   public string Title { get; set; }
   public double Latitude { get; set; }
   public double Longitude { get; set; }
   public string Description { get; set; }
   public int RSVPCount { get; set; }
}

public class SearchController : Controller {

   DinnerRepository dinnerRepository = new DinnerRepository();

   //
   // AJAX: /Search/SearchByLocation
   [AcceptVerbs(HttpVerbs.Post)]
   public ActionResult SearchByLocation(float longitude, float latitude) {

     var dinners = dinnerRepository.FindByLocation(latitude, longitude);

     var jsonDinners = from dinner in dinners
                           select new JsonDinner {
                              DinnerID = dinner.DinnerID,
                              Latitude = dinner.Latitude,
                              Longitude = dinner.Longitude,
                              Title = dinner.Title,
                              Description = dinner.Description,
                              RSVPCount = dinner.RSVPs.Count
                           };

     return Json(jsonDinners.ToList());
   }
}
</code></pre>
<p>En interne, l'action SearchByLocation() du contrôleur SearchController fait
appel à la méthode FindByLocation() de la classe DinnerRepository pour obtenir
une liste des dîners prévu à proximité. Et au lieu de faire suivre directement
cette liste d'objets Dinner au client, elle lui renvoie plutôt des objets
JSonDinner. Cette classe JsonDinner reprend un sous-ensemble des propriétés de
la classe Dinner (et par exemple elle n'indique pas le nom des personnes
inscrites à un dîner pour des raisons de sécurité). Elle contient en plus une
propriété RSVPCount qui n'existe pas au niveau de l'objet Dinner - et qui est
calculée de façon dynamique en comptant le nombre d'objets RSVP rattachés à un
dîner donné.</p>
<p>Puis nous utilisons la méthode helper Json() disponible au niveau de la
classe Controller pour renvoyer une séquence de dîners en utilisant un format
JSON. JSON est un format texte standardisé qui sert à représenter des
structures de données simples. Vous pouvez voir ci-dessous à quoi ressemble une
liste JSON de deux objets JsonDinner, tels qu'ils sont renvoyés par la méthode
d'action SearchByLocation() :</p>
<pre><code> [{&quot;DinnerID&quot;:53,&quot;Title&quot;:&quot;Dinner with the Family&quot;,&quot;Latitude&quot;:47.64312,&quot;Longitude&quot;:-
122.130609,&quot;Description&quot;:&quot;Fun dinner&quot;,&quot;RSVPCount&quot;:2}, {&quot;DinnerID&quot;:54,&quot;Title&quot;:&quot;Another
Dinner&quot;,&quot;Latitude&quot;:47.632546,&quot;Longitude&quot;:-122.21201,&quot;Description&quot;:&quot;Dinner with
Friends&quot;,&quot;RSVPCount&quot;:3}]
</code></pre>
<h2>Appeler l'action Ajax qui renvoie des données JSON via jQuery</h2>
<p>Nous sommes maintenant prêts à compléter la page d'accueil de l'application
NerdDinner pour exploiter la méthode d'action SearchByLocation du contrôleur
SearchController. Pour cela, nous allons ouvrir la vue /Views/Home/Index.aspx
et lui ajouter une zone de saisie, un bouton de recherche, notre carte et un
élément &lt;div&gt; nommé dinnerList :</p>
<pre><code>&lt;script src=&quot;http://dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=6.2&quot;
type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;/Scripts/Map.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

&lt;h2&gt;Find a Dinner&lt;/h2&gt;

&lt;div id=&quot;mapDivLeft&quot;&gt;

   &lt;div id=&quot;searchBox&quot;&gt;
     Enter your location: &lt;%= Html.TextBox(&quot;Location&quot;) %&gt;
     &lt;input id=&quot;search&quot; type=&quot;submit&quot; value=&quot;Search&quot; /&gt;
   &lt;/div&gt;

   &lt;div id=&quot;theMap&quot;&gt;
   &lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;mapDivRight&quot;&gt;
   &lt;div id=&quot;dinnerList&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Nous ajoutons ensuite les deux fonctions JavaScript suivantes à notre
page :</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;

   $(document).ready(function() {
     LoadMap();
   });

   $(&quot;#search&quot;).click(function(evt) {
     var where = jQuery.trim($(&quot;#Location&quot;).val());

     if (where.length &lt; 1)
        return;

     FindDinnersGivenLocation(where);
   });
&lt;/script&gt;
</code></pre>
<p>La première fonction JavaScript charge la carte lors du premier chargement
de la page. La seconde fonction JavaScript défini un évènement &quot;click&quot; pour le
bouton de recherche. Quand ce bouton est pressé, cela appelle la fonction
JavaScript FindDinnersGivenLocation() que nous allons ajouter à notre fichier
Map.js :</p>
<pre><code>function FindDinnersGivenLocation(where) {
   map.Find(&quot;&quot;, where, null, null, null, null, null, false,
                null, null, callbackUpdateMapDinners);
}
</code></pre>
<p>La fonction FindDinnersGivenLocation() appelle la fonction map.Find() du
contrôle Virtual Earth pour centrer la carte par rapport à l'emplacement qui a
été saisi. Une fois l'appel au service de carte de Virtual Earth terminé, la
méthode map.Find() invoque la fonction callbackUpdateMapDinners qui correspond
au dernier argument que nous lui avons passé.</p>
<p>C'est dans la méthode callbackUpdateMapDinners() que s'effectue en fait tout
le traitement. Elle emploie la méthode $.post() de jQuery pour réaliser un
appel Ajax vers la méthode d'action SearchByLocation() du contrôleur
SearchController - en lui faisant passer la latitude et la longitude qui
correspond à la carte. Elle défini une fonction inline qui sera appelée au
retour de la méthode $.post() en utilisant la variable &quot;dinners&quot; pour lui faire
passer la liste des dîners renvoyés au format JSON par la méthode d'action
SearchByLocation(). Elle fait ensuite une boucle foreach sur ces dîners afin
d'utiliser la latitude, la longitude et quelques autres informations de chaque
dîner pour placer une nouvelle punaise sur la carte. Ces dîners sont également
insérés dans une liste HTML des dîners qui apparait à droite de la carte. Pour
finir, elle déclare un évènement &quot;hover&quot; pour afficher des informations
complémentaires lorsqu'on passe la souris au-dessus des punaises ou de la liste
HTML :</p>
<pre><code>function callbackUpdateMapDinners(layer, resultsArray,
                                      places, hasMore, VEErrorMessage) {
   $(&quot;#dinnerList&quot;).empty();
   clearMap();
   var center = map.GetCenter();

   $.post(
     &quot;/Search/SearchByLocation&quot;,
     {
        latitude: center.Latitude,
        longitude: center.Longitude
     },
      function(dinners) {
         $.each(dinners, function(i, dinner) {

           var LL = new VELatLong(dinner.Latitude,
                                      dinner.Longitude, 0, null);

           var RsvpMessage = &quot;&quot;;

           if (dinner.RSVPCount == 1)
               RsvpMessage = &quot;&quot; + dinner.RSVPCount + &quot; RSVP&quot;;
           else
                RsvpMessage = &quot;&quot; + dinner.RSVPCount + &quot; RSVPs&quot;;

           // Add Pin to Map
           LoadPin(LL, '&lt;a href=&quot;/Dinners/Details/' + dinner.DinnerID + '&quot;&gt;'
                            + dinner.Title + '&lt;/a&gt;',
                           &quot;&lt;p&gt;&quot; + dinner.Description + &quot;&lt;/p&gt;&quot; + RsvpMessage);

           //Add a dinner to the &lt;ul&gt; dinnerList on the right
           $('#dinnerList').append($('&lt;li/&gt;')
                              .attr(&quot;class&quot;, &quot;dinnerItem&quot;)
                              .append($('&lt;a/&gt;').attr(&quot;href&quot;,
                                         &quot;/Dinners/Details/&quot; + dinner.DinnerID)
                               .html(dinner.Title)).append(&quot; (&quot;+RsvpMessage+&quot;)&quot;));
        });

        // Adjust zoom to display all the pins we just added.
        if (points.length &gt; 1) {
              map.SetMapView(points);
        }

        // Display the event's pin-bubble on hover.
         $(&quot;.dinnerItem&quot;).each(function(i, dinner) {
           $(dinner).hover(
                 function() { map.ShowInfoBox(shapes[i]); },
                function() { map.HideInfoBox(shapes[i]); }
           );
         });

     },
     &quot;json&quot;);

}
</code></pre>
<p>Quand nous relançons l'application, la page d'accueil contient désormais une
carte. Et quand nous saisissons le nom d'une ville, cette carte affiche les
dîners prévus dans la région :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image133.png" alt=""></p>
<p>Il suffit alors de passer la souris sur l'un deux pour obtenir des
informations supplémentaires :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image138.png" alt=""></p>
<p>Nous pouvons cliquer sur le titre du dîner - aussi bien sur la carte que
dans la liste HTML latérale - pour consulter le détail d'un dîner, auquel nous
pouvons éventuellement nous inscrire :</p>
<p><img src="http://nerddinnerbook.s3.amazonaws.com/Images/image139.png" alt=""></p>
<hr>
<p>Index : <a href="http://tinyurl.com/NerdDinnerFR">NerdDinner en français</a> - Suite : <a href="/nerddinner/realiser-tests-unitaires/">Réaliser des tests unitaires</a></p>


  </div>

</article>


<div class="pub"><ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-5475403929650645"
     data-ad-slot="8049019520"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins></div>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>


    <footer>
      <a href="/">blog.pagesd.info</a> //
      <a href="https://www.solitaire-play.com/">www.solitaire-play.com</a>
      <a rel="me" href="https://pouet.chapril.org/@ms_michel"></a>
    </footer>

  </div>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5475403929650645"
     crossorigin="anonymous"></script>
  </body>

</html>
